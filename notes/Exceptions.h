/*
`````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````
	<---- Process State and Program Review ---->

	Recall that when a program executes, the program counter (PC) plays a critical role in directing the flow of execution.
	The PC contains the memory address of the next machine instruction to be executed. The CPU fetches the instruction from
	the address stored in the PC, executes it, and then increments the PC to point to the address of the following instruction. 

	*** HOCA & General OS implementation Notes ***

	typedef struct state_t {
			int      s_r[17];	    // d0-d7, a0-a7 + pc
	#define s_sp     s_r[15]        // stack pointer
	#define s_pc     s_r[16]	    // program counter
			sr_t     s_sr;	        // status register
			...
	};

	typedef struct sr_t {
	   unsigned ps_t   :1,          // trace
					   :1,
				ps_s   :1,          // processor mode
				ps_m   :1,          // translation
					   :1,          // wait
				ps_int :3,          // interrupt mask
					   :3,
				ps_x   :1,          // extend
				ps_n   :1,          // negative
				ps_z   :1,          // zero
				ps_o   :1,          // overflow
				ps_c   :1;          // carry
	} sr_t;

	The Program Counter (PC) [state_t.s_sp] is a register that:
	- Stores the memory address of the next instruction to be executed in the program.
	- Automatically increments after fetching an instruction (unless altered by a branch, jump, or interrupt).
		Critical for:
		- Tracking the execution flow of a process.
		- Allowing the OS to pause and resume processes during context switching by saving and restoring the PC.

	The Status Register (SR) [state_t.sr_t] is a bitfield register that:
	- Reflects the state of the program/process after each instruction is executed
	- Contains flags that represent conditions after an operation, including:
		- Arithmetic/logic results (e.g., zero, negative, overflow, carry).
		- Processor mode (e.g., user mode or system/kernel mode).
		- Interrupt mask (controls which interrupt levels are enabled/disabled).
		- Translation bit (enables/disables memory address translation).
		- Zero (ps_z): Set to 1 if the result of the operation is 0.
		- Negative (ps_n): Set to 1 if the result is negative (typically, when the most significant bit is set).
		- Carry (ps_c): Set to 1 if there’s a carry out or borrow in an arithmetic operation.
		- Overflow (ps_o): Set to 1 if an arithmetic operation exceeds the range of the data type (e.g., addition of two large positive numbers resulting in a negative value).


	** Analysis **
	During program execution, the CPU processes instructions fetched via the program counter (PC). After each instruction is executed,
	any operations involving arithmetic (e.g., addition, subtraction) or logic (e.g., AND, OR, shifts) may update specific flags in the status register (`sr_t`).
	This reflected the outcome of the operation, such as whether the result was zero, negative, or caused an overflow or carry.
	This allows the CPU to make decisions and control program flow based on these instruction execution results .


	<---- Exceptions: Traps and Interrupts ---->

	During the execution of some instructions by the CPU, there are TWO TYPES of events that can alter the program's execution flow FROM OUTSIDE THE PROGRAM'S code:

	TRAPS:
	- Synchronous events generated by the processor as a result of executing certain instructions that trigger exceptional conditions.
		- Examples include:
		- Illegal operation codes (e.g., executing an invalid or undefined instruction).
		- Division by zero.
		- Segment or page faults caused by accessing invalid memory addresses.

	** Traps are intentionally designed mechanisms to invoke the EXCEPTION PROCESSOR, allowing the kernel to handle these issues gracefully.

	INTERRUPTS:
	- Asynchronous events triggered by external sources, typically I/O devices or hardware timers (Disks, Terminal, Clocks, etc.)
		- These events fall under the Interrupt-Driven Architecture, where the CPU's control flow is temporarily diverted to 
		  handle an external event (e.g., a device signaling that it has completed an operation).
		- Once the interrupt is serviced by the exception processor, the CPU resumes the program execution from where it was interrupted.


	<--- Exception Processing and Exception Vector Table --->

	When the CPU detects a trap condition (like division by zero), it immediately switches to Supervisor mode to gain privileged access.
	The CPU saves the current program's context, including the Program Counter and Status Register. Since the kernel code is already in memory, the CPU can invoke the
	pertinent routine. The Kernel Code, running on the CPU, looks up the APPROPRIATE HANDLER*** from the Exception Vector Table and executes it to handle the specific trap condition. 
	Once complete, the CPU switches back to user mode and restores the saved context to resume the original program's execution via the saved PC and SR.

	*** Handler Address -> The Vectored Exception Table ***
	- Every exception has an exception number. This indexes into a table of addresses that the OS loads before enabling Exceptoin Handling

	HOCA & EMACSIM-SPECIFIC Exception Process Handling:
	- The series of actions taken by the CPU is called Exception Processing.
	- The first 1K of memory is reserved for Exception Processing. This area of memory forms a table called the Exception Vector Table or EVT.
	- This table contains 256 entries, each of them is 4 bytes long and can hold the address of a service routine. 
	- When an exception occurs, the CPU identifies the exception and this determines the Exception Vector Number. ****
	- Then the CPU stores the Status Register (SR) in an internal register, sets the SUPERVISOR/KERNEL bit, clears the TRACE bit and sets the interrupt level to that of the exception. ****
	- The address of the exception vector is found by multiplying the Exception Vector by 4. 
	- The PC (Program Counter) and SP (Stack Pointer) are pushed on the SSP (stack). The Program Counter (PC) is then loaded with the contents at the address of the exception vector.
	- If there is no valid address there the CPU is halted!!!

	Basic Steps:
	– When an exception occurs the PC is loaded with a prearranged address of a “handler”
	– The exception mechanism takes measures to be able to return to the point of exception
	– The handler executes in privileged mode.


	Privileged Mode:
	– Every CPU has one or more privilege levels. Some instructions and addresses can only be accessed in privilege mode. 
	– The exception mechanism beside setting the PC to the handler address, also sets the bit in the CPU enabling the required privilege mode so that the handler can do its job.
	- This typically allows the handler access to device hardware, OS buffers, and the users address space
	- Return from the handler to the point of exception must restore the saved state including the original privilege leve;



	<--- Exception & Interrupt Driven Events --->
	- Timesharing is a computing technique that allows multiple users or programs to apparently run simultaneously by rapidly switching the CPU between
	  different processes, giving each one short bursts of processing time rather than letting each process run to completion.
	- Ideally interactive devices like the terminal, keyboard, and mouse


	<--- Memory Management Traps --->
	Memory management traps occur when a program attempts illegal memory operations like:
	  - Accessing restricted memory areas
	  - Page faults (accessing memory not currently in physical RAM)
	  - Stack overflow/underflow
	  - Segmentation violations

	The OS catches these traps and handles them appropriately - either by loading required memory
	pages or terminating the program if the access was invalid.

















`````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````
*/
