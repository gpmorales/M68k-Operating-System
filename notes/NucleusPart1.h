/*
	The purpose of the Nucleus is to provide an Environment
	in which ASYNCHRONOUS sequential processes exist, as well as to
	provide synchronization primivites for these process. This implies
	that the nucleus mus do low-level CPU scheduling. Additionally the
	nucleus provides facilities for 'passing up' conditions such as 
	program traps, memory management traps, and certain system call traps. 
*/

/*

	--- Nucleus Phase 1 ---

	- We will handle traps in this first part of the nucleus's construction.
	- The instructions implemented by the nucleus are invoked when a process calls
	  the corresponding SYS function. In addition, traps cause the nucleus to take
	  actions. In particular, the nucleus transforms SYS, program, and memory management
	  traps into procedure calls
	- The nucleus frequently deals with regions of memeory containing a 76-btye of
	  copy of the processor state, i.e., D0-D7, A0-A6, SP, PC, SR, and the CRP registers


	--- First Part Traps ---

	- The nucleus adds processes to the ready queue and allows the process
	  at the head of the queue to execute. In the first part of a process will execute
	  until it finished or until it finished or until it blocks itself on a semaphore.


	--- Handling Traps ---

	After bootstraping the OS, processes run in user mode.
	If a process executes an instruction (via the CPU obv) or causes a
	condition, the following will happen.

	- The trap initiates the transition
	- Hardware mechanisms (like the processor's mode bit) actually set kernel mode
	- Then the kernel routines can execute
	- After handling, the processor returns to user mode

	*** In other words the CPU enters kernel mode briefly to handle traps when they occur, 
		then returns to executing user processes.
		

	Traps generated by SYS routines cause the nucleus to perform some service on behalf of the
	process executing the instruction. System traps (other than the ones we implement) and all
	program and memory management traps can be 'passed up' by the kernel to the process responsible
	for them. From the POV of a process, the old process state and registers are saved in memory
	and the new one is loaded from a different place in memory (Exception Vector Table). 
	These 2 memory addresses constitute the process's trap state vector. This is initialized by a
	process when it executes a SYS5 instruction.

	- SYS routine traps trigger kernel services
	- Traps can be passed to responsible processes
	- Process state/registers are saved and new ones loaded from EVT
	- Trap state vector contains the memory addresses
	- SYS5 initializes this vector


	--- Processor State (See types.h) & the Kernel ---
	Yes - this processor state struct shows the kernel can access/modify:

	- d0-d7 (data registers)
	- a0-a7 (address registers)
	- pc (program counter)
	- sr (status register)
	- tmp (temporary storage)
	- crp (segment table address)

	The 76 bytes likely comes from: 17 registers × 4 bytes + 4 bytes (sr) + 2 bytes (tmp) + 4 bytes (crp) = 76 bytes






*/